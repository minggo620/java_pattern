# java_pattern
##abstractfactory
/**
 * 抽象工厂模式
 * 1.抽象工厂模式针对的对象是工厂的抽象定义。
 * 2.工厂模式针对的对象是生产产品供给封装。
 * @author minggo
 * @time 2017年7月12日上午11:42:20
 */
##adapter
/**
 * 适配器模式
 * 为了两边的数据对称输入输出
 * @author minggo
 * @time 2017年7月13日下午5:27:53
 */
 ##bridge
 /**
 * 桥接模式
 * 1.处理面向对象继承耦合问题。
 * 2.符合开闭原则。
 * 3.灵活扩展性强。
 * @author minggo
 * @time 2017年7月12日下午12:50:15
 */
 ##构建这模式
 /**
 * 构建者模式
 * 1.构建的流程在Director身上，不在构建者builder里。
 * 2.构造者模式跟策略模式方法调用流程一样，但是构建返回结果是构建出来的对象。
 * @author minggo
 * @time 2017年7月14日下午2:19:23
 */
 ##chainofresponsibility
 /**
 * 责任链模式
 * 1.关键是建立完成的等级传递链。
 * 2.事件处理器中要给每一处理添加下一级处理器（非最后一级）。
 * @author minggo
 * @time 2017年7月17日下午3:25:49
 */
 ##command
 /**
 * 命令模式
 * 1.也是强调封装命令使得请求者和实现者解耦。
 * 2.相对面门模式，多了是对命令（发情的事情源）的封装，相同的是都有执行的和调度者。
 * 3.命令模式关注问题是解耦问题。
 * 4.策略模式关注问题是算法替代问题。
 * 5.最大的不同在于策略模式是命令模式接收者（UML图上容易理解）
 * @author minggo
 * @time 2017年7月13日上午11:11:29
 */
 ##composite
 /**
 * 组合模式
 * 1.强调将有关系的类组合形成结构。
 * 2.跟装饰器模式区别是不修改原有的功能。
 * 3.装饰器模式强调功能类的扩展。
 * @author minggo
 * @time 2017年7月13日下午5:24:24
 */
 ##decorator
 /**
 * 装饰器模式
 * 1.核心构建一个装饰器，继承组件抽象类和持有一个组件实例。
 * 2.解决多继承，变动较大业务模块设计
 * @author minggo
 * @time 2017年7月13日上午11:22:48
 */
 ##facade
 /**
 * 门面模式（强调封装）
 * 1.不需要亲力亲为把不需要关注的事做一遍。
 * 2.只关注核心信息的传递。
 * @author minggo
 * @time 2017年7月13日上午10:27:17
 */
 ##factory
 /**
 * 工厂模式(1.区别于策略模式返回的是产品本身，不具有使用产品的操作方法 2.区别于享元模式是没有把产品保存在列表当中重用)
 * @author minggo
 * @time 2017年7月12日上午11:48:13
 */
 ##flyweight
 /**
 * 享元模式
 * 1.不同于工厂模式是将生产对象保存下来
 * @author minggo
 * @time 2017年7月18日下午6:33:36
 */
 ##interpreter
 /**
 * 解释器模式 
 * 1.基本用不到的设计模式。 
 * 2.作用是解析语法树的设计模式。 
 * 3.像计数器，shell，dos
 * @author minggo
 * @time 2017年7月18日下午6:32:51
 */
  ##iterator
 /**
 * 迭代器模式
 * 1.自己封装一个迭代器情况极少，面向对象语言基本提供了迭代器。
 * 2.可以做一些扩展，比如前序遍历，中序遍历和后续遍历算法迭代封装。
 * @author minggo
 * @time 2017年7月12日下午5:48:41
 */
 ##mediator
 /**
 * 中介者模式
 * 1.使用原则是有3个以上的独立业务两两依赖时采用该模式。
 * 2.体现每一个独立的业务和中介之间相互持有关系。
 * 3.业务的流程只交给中介者持有，相对观察者和代理都是不着重在某一个业务方。
 * 4.解耦的同时，也容易加重中介者逻辑负担。
 * 5.适合做独立产品开发，强调稳定高效。
 * @author minggo
 * @time 2017年7月12日下午4:14:41
 */
 ##memento
 /**
 * 备忘录模式
 * 1.备忘发起者，备忘管理者和备忘录。
 * 2.使用的不多，常见的数据库数据回滚。
 * @author minggo
 * @time 2017年7月18日下午6:32:31
 */
 ##observer
 /**
 * 观察者模式
 * 1.被观察者需要持有一个或者多个观察者。
 * 2.区别于代理模式是功能不一样，观察者负责反馈结果，代理是同根负责做同样的事情。
 * 3.订阅者是一个接口完成，被订阅的这类就不单独抽出来写，这个代码已经足够说明这个模式。
 * @author minggo
 * @time 2017年7月17日下午2:13:54
 */
 ##prototype
 /**
 * 原型模式
 * 1.一种拷贝方式对对象进行拷贝一份。
 * 2.注意浅拷贝和深拷贝。
 * @author minggo
 * @time 2017年7月18日下午5:22:13
 */
 ##proxy
 /**
 * 代理模式特点：代理类，必须拥有具体实现类，两者都是实现同一个“根”接口
 * @author minggo
 * @time 2017年7月12日上午11:48:40
 */
 ##singleton
 /**
 * 单例模式：
 * 1.资源全局共享。
 * 2.实例唯一性。
 * 3.实例公开性。
 * 4.不适宜存放过多占内存信息。
 * @author minggo
 * @time 2017年7月12日上午11:52:27
 */
 ##state
 /**
 * 状态模式
 * 1.跟策略一样的是都在Context中执行操作方法。
 * 2.跟策略不一样的是每种状态执行会影响其他状态执行的结果。
 * @author minggo
 * @time 2017年7月18日下午5:10:47
 */
 ##strategy
 /**
 * 策略模式
 * 1.相比工厂模式多了doIt方法由Context交给Client 。
 * 2.相对代理模式少了”同根“和条件不是有外边传进来 。
 * 3.工厂构建出非工厂正式产品，策略会构建同一个Context外包装包装。
 * 4.策略强调提供方案，工厂强调提供产品，容易混淆的地方就是”方案就是一种产品“。
 * 
 * @author minggo
 * @time 2017年7月12日上午11:50:19
 */
 ##templatemethod
 /**
 * 模板方法模式，就是方法的封装
 * @author minggo
 * @time 2017年7月14日上午11:48:08
 */
 ##visitor
 /**
 * 访问者模式
 * 
 * @author minggo
 * @time 2017年7月17日下午6:30:24
 */
 
